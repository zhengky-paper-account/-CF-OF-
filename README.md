# -CF-OF-
1.无符号数：CF为cary flag进位/借位标记，当2个数相加产生了进位时或2个数相减产生了借位时，CF=1
<img width="267" height="49" alt="图片" src="https://github.com/user-attachments/assets/a35888a8-deb9-407d-8106-40af90001a7a" />
<img width="980" height="467" alt="图片" src="https://github.com/user-attachments/assets/95c99d11-e57f-4f69-a14a-3ef68aae4995" />
<img width="1657" height="294" alt="图片" src="https://github.com/user-attachments/assets/b6302168-3f5d-4677-86aa-ce1cfe4f6dd4" />

2.有符号数：OF为overflow flag溢出标记，当运算结果result溢出时，OF=1；未溢出时，OF=0
OF的计算方法：
<img width="1511" height="462" alt="图片" src="https://github.com/user-attachments/assets/389ff910-fd16-4b1d-9e8f-7e4ab2076d30" />
<img width="1581" height="782" alt="图片" src="https://github.com/user-attachments/assets/1190561f-652f-4e81-93dc-9603260590a7" />
<img width="1696" height="862" alt="图片" src="https://github.com/user-attachments/assets/8eae6b0a-9f3e-4874-b6f5-51984afaaa66" />
<img width="1695" height="787" alt="图片" src="https://github.com/user-attachments/assets/388784ad-84c9-438d-8b90-7429ea70023f" />
注：从图形上理解，为什么原码数值相加有进位，补码数值相加就没有进位：两个数原码相加大于360度，两个原码、补码相加一共720度，那么两个补码相加一定小于360度
<img width="440" height="236" alt="图片" src="https://github.com/user-attachments/assets/3c9e8351-a4b5-4a7d-b85e-c4cbeecf7667" />
<img width="1702" height="791" alt="图片" src="https://github.com/user-attachments/assets/e2928036-4d87-49f1-a149-93ea1b0e0dc9" />

3 功能设计流程图

3.1 程序主流程图

```mermaid
flowchart TD
    A[程序开始] --> B[显示主菜单]
    B --> C{数据是否已加载?}
    C -->|否| D[选择输入方式]
    C -->|是| E[显示当前数据]
    D --> F{选择1或2?}
    F -->|1| G[手动输入数据]
    F -->|2| H[使用示例数据]
    G --> I[输入物理页框数]
    I --> J[输入页面访问序列]
    J --> K[数据加载完成]
    H --> K
    K --> E
    E --> L[显示算法选择菜单]
    L --> M{选择算法}
    M -->|1| N[执行FIFO算法]
    M -->|2| O[执行LRU算法]
    M -->|3| P[执行OPT算法]
    M -->|4| Q[执行Random算法]
    M -->|5| R[退出程序]
    N --> S[输出结果]
    O --> S
    P --> S
    Q --> S
    S --> B
    R --> T[程序结束]
```

程序主流程图描述了从程序启动到退出的完整流程。程序采用循环菜单结构，用户首先需要选择输入方式（手动输入或使用示例数据），然后可以反复选择不同的算法执行，每次执行完成后返回主菜单，方便用户对比不同算法的性能。流程图中的菱形节点表示判断条件，矩形节点表示处理步骤，箭头上的标签表示条件分支。

3.2 算法执行流程图

```mermaid
flowchart TD
    A[算法执行开始] --> B[初始化数据结构]
    B --> C[清空内存状态记录]
    C --> D[遍历页面访问序列]
    D --> E{当前页面是否在内存中?}
    E -->|是| F[更新页面状态]
    E -->|否| G[发生缺页中断]
    F --> H[记录当前内存状态]
    G --> I{页框是否已满?}
    I -->|否| J[直接加入页面]
    I -->|是| K[选择置换页面]
    K --> L[执行页面置换]
    J --> M[缺页次数加1]
    L --> M
    M --> H
    H --> N{是否还有未访问的页面?}
    N -->|是| D
    N -->|否| O[计算缺页率]
    O --> P[输出结果]
    P --> Q[算法执行结束]
```

算法执行流程图描述了页面置换算法的通用执行流程，适用于所有四种算法。流程从初始化开始，然后遍历页面访问序列。对于每个页面，首先检查是否已在内存中，如果在则更新状态，如果不在则发生缺页中断。缺页时根据页框是否已满决定直接加入还是执行置换。每处理完一个页面后记录当前内存状态，直到所有页面处理完成，最后计算缺页率并输出结果。

3.3 FIFO算法流程图

```mermaid
flowchart TD
    A[FIFO算法开始] --> B[初始化页框向量和循环指针]
    B --> C[遍历页面访问序列]
    C --> D{页面是否在内存中?}
    D -->|是| E[记录非缺页状态]
    D -->|否| F[缺页次数加1]
    F --> G{页框是否已满?}
    G -->|否| H[将页面加入页框]
    G -->|是| I[替换nextFrameIndex指向的页框]
    I --> J[nextFrameIndex循环递增]
    J --> K[记录淘汰页号]
    H --> L[记录新加入状态]
    E --> M[记录当前内存状态]
    K --> M
    L --> M
    M --> N{是否还有未访问的页面?}
    N -->|是| C
    N -->|否| O[算法结束]
```

FIFO算法流程图展示了先进先出算法的具体执行过程。算法使用循环队列的思想，维护一个nextFrameIndex指针指向下一个要替换的页框。当发生缺页且页框已满时，替换nextFrameIndex指向的页框，然后将nextFrameIndex循环递增。这样保证了最早进入内存的页面最先被替换，符合FIFO策略。流程图清晰地展示了页面检查、缺页处理、循环指针更新和状态记录的完整过程。

3.4 LRU算法流程图

```mermaid
flowchart TD
    A[LRU算法开始] --> B[初始化双向链表和哈希表]
    B --> C[遍历页面访问序列]
    C --> D{页面是否在内存中?}
    D -->|是| E[从链表中移除该页面]
    E --> F[将页面移到链表末尾]
    F --> G[更新哈希表]
    G --> H[记录非缺页状态]
    D -->|否| I[缺页次数加1]
    I --> J{页框是否已满?}
    J -->|否| K[将页面加入链表末尾]
    J -->|是| L[移除链表头部页面]
    L --> M[记录淘汰页号]
    M --> N[将新页面加入链表末尾]
    K --> O[更新哈希表]
    N --> O
    O --> P[记录新加入状态]
    H --> Q[记录当前内存状态]
    P --> Q
    Q --> R{是否还有未访问的页面?}
    R -->|是| C
    R -->|否| S[算法结束]
```

LRU算法流程图展示了最近最久未使用算法的具体执行过程。算法使用双向链表维护页框，链表头部是最久未使用的页面，链表尾部是最近使用的页面。当页面被访问时，如果已在内存中，则将其从链表中移除并移到链表末尾，标记为最近使用。当发生缺页且页框已满时，移除链表头部的页面（最久未使用），将新页面加入链表末尾。哈希表用于快速查找页面在链表中的位置，实现O(1)的更新操作。流程图详细展示了链表维护、哈希表更新和页面置换的完整逻辑。

3.5 OPT算法流程图

```mermaid
flowchart TD
    A[OPT算法开始] --> B[初始化页框向量]
    B --> C[遍历页面访问序列]
    C --> D{页面是否在内存中?}
    D -->|是| E[记录非缺页状态]
    D -->|否| F[缺页次数加1]
    F --> G{页框是否已满?}
    G -->|否| H[将页面加入页框]
    G -->|是| I[调用findVictim函数]
    I --> J[遍历内存中的每个页面]
    J --> K[查找页面下一次使用位置]
    K --> L[选择未来最久不会被使用的页面]
    L --> M[记录淘汰页号]
    M --> N[替换选中的页面]
    H --> O[记录新加入状态]
    E --> P[记录当前内存状态]
    N --> P
    O --> P
    P --> Q{是否还有未访问的页面?}
    Q -->|是| C
    Q -->|否| R[算法结束]
```

OPT算法流程图展示了理想型淘汰算法的具体执行过程。OPT算法需要预知未来的页面访问序列，选择未来最久不会被使用的页面进行置换。当发生缺页且页框已满时，算法调用findVictim函数，该函数遍历内存中的每个页面，在未来的访问序列中查找它下一次被使用的位置。如果某个页面永远不会再被使用，优先选择它；否则，选择未来最久不会被使用的页面（即下一次使用位置最远的页面）。流程图展示了未来序列查找和最优页面选择的完整过程，这是OPT算法实现理论最优性能的关键步骤。

3.6 Random算法流程图

```mermaid
flowchart TD
    A[Random算法开始] --> B[初始化页框向量和访问计数]
    B --> C[遍历页面访问序列]
    C --> D{页面是否在内存中?}
    D -->|是| E[增加页面访问计数]
    E --> F[记录非缺页状态]
    D -->|否| G[缺页次数加1]
    G --> H{页框是否已满?}
    H -->|否| I[将页面加入页框]
    I --> J[访问计数初始化为1]
    H -->|是| K[遍历访问计数]
    K --> L[找到访问计数最少的页面]
    L --> M[记录淘汰页号]
    M --> N[替换选中的页面]
    N --> O[新页面访问计数初始化为1]
    J --> P[记录新加入状态]
    F --> Q[记录当前内存状态]
    O --> Q
    P --> Q
    Q --> R{是否还有未访问的页面?}
    R -->|是| C
    R -->|否| S[算法结束]
```

Random算法流程图展示了随机淘汰算法的具体执行过程。本实验实现的Random算法并非真正的随机，而是基于访问频率的策略：每次淘汰被访问概率最低的页面（访问次数最少的页面）。算法维护每个页面的访问计数，当页面被访问时，如果已在内存中，则增加其访问计数。当发生缺页且页框已满时，遍历访问计数，找到访问计数最少的页面进行置换。新加入的页面访问计数初始化为1。流程图展示了访问计数维护、最少访问页面查找和页面置换的完整过程，体现了基于访问频率的置换策略。

3.7 输出模块流程图

```mermaid
flowchart TD
    A[输出模块开始] --> B[输出算法名称]
    B --> C[输出物理页框数]
    C --> D[输出页面访问序列]
    D --> E[输出缺页次数]
    E --> F[计算并输出缺页率]
    F --> G[输出内存状态变化表标题]
    G --> H[输出页面访问序列行]
    H --> I[遍历每个页框]
    I --> J[输出页框标签]
    J --> K[遍历每个时刻]
    K --> L[输出页框内容]
    L --> M{是否还有未输出的页框?}
    M -->|是| I
    M -->|否| N[输出淘汰页号行]
    N --> O[遍历每个时刻]
    O --> P{是否有淘汰页号?}
    P -->|是| Q[输出淘汰页号]
    P -->|否| R[输出空白]
    Q --> S{是否还有未输出的时刻?}
    R --> S
    S -->|是| O
    S -->|否| T[输出结束]
```

输出模块流程图描述了结果输出的详细过程。输出分为三个部分：基本信息输出、内存状态变化表输出和淘汰页号输出。基本信息包括算法名称、物理页框数、页面访问序列、缺页次数和缺页率。内存状态变化表首先输出页面访问序列行，然后遍历每个页框，输出每个页框在不同时刻的内容，确保列对齐。最后输出淘汰页号行，对于每个时刻，如果有淘汰页号则输出，否则输出空白。流程图展示了格式化输出的完整过程，包括标签宽度计算、列对齐处理和表格格式控制，确保输出结果清晰易读。
