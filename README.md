# -CF-OF-
1.无符号数：CF为cary flag进位/借位标记，当2个数相加产生了进位时或2个数相减产生了借位时，CF=1
<img width="267" height="49" alt="图片" src="https://github.com/user-attachments/assets/a35888a8-deb9-407d-8106-40af90001a7a" />
<img width="980" height="467" alt="图片" src="https://github.com/user-attachments/assets/95c99d11-e57f-4f69-a14a-3ef68aae4995" />
<img width="1657" height="294" alt="图片" src="https://github.com/user-attachments/assets/b6302168-3f5d-4677-86aa-ce1cfe4f6dd4" />

2.有符号数：OF为overflow flag溢出标记，当运算结果result溢出时，OF=1；未溢出时，OF=0
OF的计算方法：
<img width="1511" height="462" alt="图片" src="https://github.com/user-attachments/assets/389ff910-fd16-4b1d-9e8f-7e4ab2076d30" />
<img width="1581" height="782" alt="图片" src="https://github.com/user-attachments/assets/1190561f-652f-4e81-93dc-9603260590a7" />
<img width="1696" height="862" alt="图片" src="https://github.com/user-attachments/assets/8eae6b0a-9f3e-4874-b6f5-51984afaaa66" />
<img width="1695" height="787" alt="图片" src="https://github.com/user-attachments/assets/388784ad-84c9-438d-8b90-7429ea70023f" />
注：从图形上理解，为什么原码数值相加有进位，补码数值相加就没有进位：两个数原码相加大于360度，两个原码、补码相加一共720度，那么两个补码相加一定小于360度
<img width="440" height="236" alt="图片" src="https://github.com/user-attachments/assets/3c9e8351-a4b5-4a7d-b85e-c4cbeecf7667" />
<img width="1702" height="791" alt="图片" src="https://github.com/user-attachments/assets/e2928036-4d87-49f1-a149-93ea1b0e0dc9" />



# 3.2 语法分析方法流程图

## 3.2.2 SLR(1)分析表构建流程图

```mermaid
flowchart TD
    开始([开始构建SLR分析表]) --> 初始化表[初始化ACTION和GOTO表<br/>ACTION表填-999<br/>GOTO表填-1]
    初始化表 --> 计算FIRST[计算FIRST集]
    计算FIRST --> 计算FOLLOW[计算FOLLOW集]
    计算FOLLOW --> 构建项目集族[构建LR项目集族]
    构建项目集族 --> 遍历项目集[遍历每个项目集]
    遍历项目集 --> 遍历项目[遍历项目集中的每个项目]
    遍历项目 --> 检查点位置{点的位置}
    检查点位置 -->|点在中间| Shift项目[处理Shift项目]
    检查点位置 -->|点在末尾| Reduce项目[处理Reduce项目]
    Shift项目 --> 检查符号类型{下一个符号类型}
    检查符号类型 -->|终结符| 填充ACTION[填充ACTION表<br/>ACTION i 终结符 = 转移状态]
    检查符号类型 -->|非终结符| 填充GOTO[填充GOTO表<br/>GOTO i 非终结符索引 = 转移状态]
    Reduce项目 --> 检查产生式{产生式编号}
    检查产生式 -->|0号产生式| 填充接受[填充ACTION表<br/>ACTION i $ = 0接受]
    检查产生式 -->|其他产生式| 填充归约[在FOLLOW集中所有符号处<br/>填充ACTION表<br/>ACTION i 符号 = -产生式编号]
    填充ACTION --> 检查下一个项目{还有项目?}
    填充GOTO --> 检查下一个项目
    填充接受 --> 检查下一个项目
    填充归约 --> 检查下一个项目
    检查下一个项目 -->|是| 遍历项目
    检查下一个项目 -->|否| 检查下一个项目集{还有项目集?}
    检查下一个项目集 -->|是| 遍历项目集
    检查下一个项目集 -->|否| 完成([构建完成])
```

## 3.2.4 FIRST集计算流程图

```mermaid
flowchart TD
    开始([开始计算FIRST集]) --> 初始化[初始化所有FIRST集为空]
    初始化 --> 设置标志[changed = true]
    设置标志 --> 循环判断{changed == true?}
    循环判断 -->|否| 完成([计算完成])
    循环判断 -->|是| 设置标志2[changed = false]
    设置标志2 --> 遍历产生式[遍历所有产生式]
    遍历产生式 --> 检查左部{左部是非终结符?}
    检查左部 -->|否| 遍历产生式
    检查左部 -->|是| 获取右部[获取产生式右部符号序列]
    获取右部 --> 遍历右部符号[遍历右部符号]
    遍历右部符号 --> 检查符号类型{符号类型}
    检查符号类型 -->|终结符| 加入FIRST[将终结符加入左部FIRST集<br/>changed = true]
    检查符号类型 -->|非终结符| 合并FIRST[将非终结符的FIRST集<br/>合并到左部FIRST集<br/>changed = true]
    加入FIRST --> 停止遍历[停止遍历右部]
    合并FIRST --> 停止遍历
    停止遍历 --> 检查下一个产生式{还有产生式?}
    检查下一个产生式 -->|是| 遍历产生式
    检查下一个产生式 -->|否| 循环判断
```

## 3.2.6 FOLLOW集计算流程图

```mermaid
flowchart TD
    开始([开始计算FOLLOW集]) --> 初始化[初始化所有FOLLOW集为空]
    初始化 --> 设置开始符号[FOLLOW集包含文件结束符]
    设置开始符号 --> 设置标志[changed = true]
    设置标志 --> 循环判断{changed == true?}
    循环判断 -->|否| 完成([计算完成])
    循环判断 -->|是| 设置标志2[changed = false]
    设置标志2 --> 遍历产生式[遍历所有产生式]
    遍历产生式 --> 检查左部{左部是非终结符?}
    检查左部 -->|否| 遍历产生式
    检查左部 -->|是| 获取右部[获取产生式右部符号序列]
    获取右部 --> 遍历右部符号[遍历右部中的每个非终结符]
    遍历右部符号 --> 检查位置{非终结符位置}
    检查位置 -->|不在末尾| 检查后继符号{后继符号类型}
    检查位置 -->|在末尾| 合并FOLLOW[将左部FOLLOW集<br/>合并到该非终结符FOLLOW集<br/>changed = true]
    检查后继符号 -->|终结符| 加入FOLLOW[将终结符加入<br/>该非终结符FOLLOW集<br/>changed = true]
    检查后继符号 -->|非终结符| 合并FIRST[将后继非终结符FIRST集<br/>合并到该非终结符FOLLOW集<br/>changed = true]
    加入FOLLOW --> 检查下一个符号{还有符号?}
    合并FIRST --> 检查下一个符号
    合并FOLLOW --> 检查下一个符号
    检查下一个符号 -->|是| 遍历右部符号
    检查下一个符号 -->|否| 检查下一个产生式{还有产生式?}
    检查下一个产生式 -->|是| 遍历产生式
    检查下一个产生式 -->|否| 循环判断
```

## 3.2.8 项目集闭包计算流程图

```mermaid
flowchart TD
    开始([开始计算闭包]) --> 设置标志[changed = true]
    设置标志 --> 循环判断{changed == true?}
    循环判断 -->|否| 完成([闭包计算完成])
    循环判断 -->|是| 设置标志2[changed = false<br/>newItems = 空列表]
    设置标志2 --> 遍历项目[遍历项目集中的每个项目]
    遍历项目 --> 获取右部[获取产生式右部]
    获取右部 --> 检查点位置{点在末尾?}
    检查点位置 -->|是| 跳过[跳过该项目]
    检查点位置 -->|否| 获取下一个符号[获取点后的下一个符号]
    获取下一个符号 --> 检查符号类型{下一个符号类型}
    检查符号类型 -->|终结符| 跳过
    检查符号类型 -->|非终结符| 查找产生式[查找所有以该非终结符为左部的产生式]
    查找产生式 --> 创建新项目[为每个产生式创建新项目<br/>点在开头位置0]
    创建新项目 --> 检查是否已存在{新项目已在项目集中?}
    检查是否已存在 -->|是| 跳过
    检查是否已存在 -->|否| 添加到列表[将新项目添加到newItems<br/>changed = true]
    添加到列表 --> 检查下一个项目{还有项目?}
    跳过 --> 检查下一个项目
    检查下一个项目 -->|是| 遍历项目
    检查下一个项目 -->|否| 合并新项目[将newItems中的所有项目<br/>添加到项目集中]
    合并新项目 --> 循环判断
```

## 3.2.10 GOTO函数流程图

```mermaid
flowchart TD
    开始([开始GOTO函数]) --> 初始化新项目集[初始化新项目集J为空]
    初始化新项目集 --> 遍历项目[遍历项目集I中的每个项目]
    遍历项目 --> 获取右部[获取产生式右部]
    获取右部 --> 检查条件{点在中间且<br/>点后符号等于X?}
    检查条件 -->|否| 检查下一个项目{还有项目?}
    检查条件 -->|是| 移动点[将点向右移动一位<br/>创建新项目]
    移动点 --> 添加到新项目集[将新项目添加到J]
    添加到新项目集 --> 检查下一个项目
    检查下一个项目 -->|是| 遍历项目
    检查下一个项目 -->|否| 计算闭包[对项目集J计算闭包]
    计算闭包 --> 返回结果([返回项目集J])
```

## 3.2.12 项目集族构建流程图

```mermaid
flowchart TD
    开始([开始构建项目集族]) --> 清空集合[清空项目集族和转移映射]
    清空集合 --> 创建初始项目集[创建初始项目集I0<br/>包含项目S' -> .S]
    创建初始项目集 --> 计算闭包[对I0计算闭包]
    计算闭包 --> 添加到族[将I0添加到项目集族]
    添加到族 --> 遍历项目集[遍历项目集族中的每个项目集]
    遍历项目集 --> 收集转移符号[收集所有可能的转移符号<br/>即点后的符号]
    收集转移符号 --> 检查符号集合{符号集合为空?}
    检查符号集合 -->|是| 检查下一个项目集{还有项目集?}
    检查符号集合 -->|否| 遍历符号[遍历每个转移符号]
    遍历符号 --> 计算GOTO[计算GOTO当前项目集,符号]
    计算GOTO --> 检查结果{GOTO结果为空?}
    检查结果 -->|是| 检查下一个符号{还有符号?}
    检查结果 -->|否| 查找相同项目集[在项目集族中查找相同的项目集]
    查找相同项目集 --> 检查是否存在{找到相同项目集?}
    检查是否存在 -->|是| 记录已有状态[记录转移映射<br/>gotoMap i 符号 = 已有状态]
    检查是否存在 -->|否| 添加新项目集[将新项目集添加到项目集族<br/>记录转移映射<br/>gotoMap i 符号 = 新状态]
    记录已有状态 --> 检查上限{项目集数量达到上限?}
    添加新项目集 --> 检查上限
    检查上限 -->|是| 报错退出[报错并退出]
    检查上限 -->|否| 检查下一个符号
    检查下一个符号 -->|是| 遍历符号
    检查下一个符号 -->|否| 检查下一个项目集
    检查下一个项目集 -->|是| 遍历项目集
    检查下一个项目集 -->|否| 完成([项目集族构建完成])
```

## 3.2.14 SLR(1)主控分析流程图

```mermaid
flowchart TD
    开始([开始语法分析]) --> 初始化分析表[初始化SLR分析表]
    初始化分析表 --> 初始化栈[初始化状态栈、符号栈、语义栈<br/>状态栈: 0<br/>符号栈: 栈底标记<br/>语义栈: 栈底标记]
    初始化栈 --> 设置输入指针[设置输入Token索引为0]
    设置输入指针 --> 循环判断{输入未结束?}
    循环判断 -->|否| 报错未处理[报错: 输入未完全处理]
    循环判断 -->|是| 获取输入符号[获取当前输入符号]
    获取输入符号 --> 检查符号{符号有效?}
    检查符号 -->|否| 报错无效符号[报错: 无法识别的符号]
    检查符号 -->|是| 获取状态[获取状态栈栈顶状态]
    获取状态 --> 查ACTION表[查ACTION表状态和输入符号]
    查ACTION表 --> 判断动作{ACTION表值}
    判断动作 -->|0| 接受[分析成功接受]
    判断动作 -->|-999| 报错语法错误[报错: 语法错误<br/>输出期望的符号列表]
    判断动作 -->|>0| 移进[执行移进动作]
    判断动作 -->|<0| 归约[执行归约动作]
    移进 --> 获取转移状态[获取转移状态nextState]
    获取转移状态 --> 压入栈[将nextState压入状态栈<br/>将输入符号压入符号栈<br/>将词法值压入语义栈]
    压入栈 --> 移动输入指针[输入指针加1]
    移动输入指针 --> 循环判断
    归约 --> 获取产生式[获取归约产生式编号]
    获取产生式 --> 检查产生式{产生式编号有效?}
    检查产生式 -->|否| 报错无效产生式[报错: 无效的产生式编号]
    检查产生式 -->|是| 检查栈元素{栈中元素足够?}
    检查栈元素 -->|否| 报错栈不足[报错: 栈元素不足]
    检查栈元素 -->|是| 弹出栈元素[从三个栈中弹出产生式长度个元素<br/>保存为右部语义值]
    弹出栈元素 --> 执行语义动作[执行产生式的语义动作<br/>生成新的语义值]
    执行语义动作 --> 查GOTO表[查GOTO表当前状态和产生式左部]
    查GOTO表 --> 检查GOTO{GOTO值有效?}
    检查GOTO -->|否| 报错GOTO无效[报错: GOTO表中无转移]
    检查GOTO -->|是| 压入新元素[将GOTO状态压入状态栈<br/>将产生式左部压入符号栈<br/>将新语义值压入语义栈]
    压入新元素 --> 循环判断
    接受 --> 完成([分析成功完成])
```

